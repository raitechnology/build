Rai Protocol for Cache Backed Pub Sub
=====================================
:toc: left

About
-----

This document describes a caching layer on top of existing pubsub systems.
Pubsub provides for a multiplexed subject adressed based stream of messages
from publisher to subscriber.  Pubsub is usually layered on top of a reliable
based transport, such as *TCP* or *PGM*.  The multicast supported by the
architectures is either point to point *TCP* fanout of subscription interest or
built on top of a reliable multicast *UDP* transport.  The publisher can be a
feed service, performing last value caching and trasforming the events into
subject streams, or it may be a cache based router, which distrubutes publisher
services across multiple nodes in order to scale networks.

The caching layer includes methods for synchronizing state distributed across a
network of nodes.  The most important of this extended functionality is
subscription management, which includes methods beyond pubsub that allow for
network endpoints, the publisher and the subscriber, to encode cache semantics,
fault tolerance, and subscription visibility.

Cache backed subscription operations
------------------------------------

. Subscription Listen

- A message from a subscriber that multicasts to a well known endpoint with
  notification of a subscripion start.  This message contains infromation
  identifying the subscriber uniquely.

. Subscription Intial

- This extends the subscription listen to also provide a subscriber endpoint
  for intializing the image associated with the subscription.

. Snapshot Intial

- A one time request for the current state of the cached image.

. Update Publish

- After one or more subscription interestes are known, the publisher provides
  updates to the subscription.

. Unsubscribe

- This message multicasts to the well known endpoint with a notification of a
  subscription stop using the unique identification sent with the subscription
  start.

. Refresh Initial

- In the event that a subject stream is disrupted by network or node failure,
  this reestablishes the initial state of the subject, which has become stale.

. Reassert Subscription

- This message resets any timers associated with subscription by the publisher.
  A publisher may drop subscriptions that have not been active after a period
  of time.

. Drop Notification

- In the event that a subscription timer expires, this notifies any subscriber
  that may be active that the publisher dropped the subscription and is no
  longer forwarding messages.  If a subscriber is still active, it must reasert
  or restart the subscription.

. Stale Notification

- If the publisher is no longer able to provide updates or has lost sequences
  of messages associated with a subject, this notifies the subscriber that the
  current state is stale.  This may cause subsribers to restart a subscription
  on another path or they may need to wait for the publisher to restore the
  subject stream.

. Not Found Notification

- When a subscription listen starts, this reply notifies the subscriber that
  the subscription is established, but that no published data is currently
  available.

. Verify Notification

- Another form of subscription listen start reply where the publisher notifies
  that no published data is available, but is expected to be ready soon.  This
  often includes a zeroed record associated with the subject so that the
  subscriber can initialize its internal state and be ready for updates.

. Feed Down

- A form of stale notification that may include information about the publisher
  state.

. Feed Switch

- A form of stale notification that indicates a gap or duplication of the
  stream may occur as the source path of the stream has changed, such as a
  primary to secondary flip.

. Subscription Expired

- If a subject stream is permanently ended, this notifies that the publisher no
  longer intends send updates.

. Subject Renamed

- When a subject stream is renamed to another, this message identifies which
  subject should be subscribed to reestablish the stream.

. Recap Publish

- When a feed switch, or primary to secondary flip, occurs, a recap of the
  latest updates are published in order to insure that the stream is up to
  date.  These messages can be combined so that all of the data up to the last
  published update are recapped for the configured time period.

. Conflated Publish

- If a subject stream has reduced bandwidth, a conflated message encodes
  multiple updates into a single update.  This allows a publisher to increase
  the reliability with a reduction in message rate when the latency of updates
  is not as important.

. Dictionary

- If a dictionary is associated with the messages sent, this well known
  endpoint can be used by subscribers to download the latest dictionary.  If a
  dictionary is not static, subscription for dictionary updates is also
  started.

. Entitlements

- When a system is designed for licensed access to data, it is necessary to
  track the activity of the subscriber.  This service endpoint encodes the
  access levels and the logging of subscription events.

. Service Directory

- A subject space is often divided into seperate services, each with it's own
  well known endpoint for establishing a subscriptions.  Traditionally, the
  first segment of the subject identifies the publsher.  For example,
  NASDAQ may be used to establish subscriptions published by the NASDAQ
  feed, and NYSE may be used for the NYSE feed.  The service directory
  names all of the publishers by their subject prefix.  It should also
  define the dictionary and entitlements well known endpoints if they
  are desired.

Protocols supported
-------------------

The following protocols will be described for each of the operations needed
for a cache aware pubsub system.

- RV
- NATS
- Redis
- Http/Websocket
- OpenPGM

RV
--

Overview
~~~~~~~~

With the *SASS2* base, most of the RV architecture already supports many of the
features needed for subscription visibility and identifying the subscriber.
The most annoying features of *SASS* is the static dictionary and the lack of
formalizing the sequence numbers of the updates.  There are two forms of
sequencing which use the same *SEQ_NO* field.  The publisher may use the
*SEQ_NO* field for sequencing the stream of data, across multiple subjects but
the subscriber needs the sequencing for each subject.  This segmentation
requires subscriber to know what variation of sequencing is used in order to
verify the sequences of updates.

The *SASS2* header includes *MSG_TYPE*, *REC_TYPE*, *SEQ_NO*, *REC_STATUS*.
The *MSG_TYPE*, *REC_STATUS* fields encode the basic response types needed,
with an optional status *TEXT* field for descriptions.  The *REC_TYPE* is
deprecated as an advisory field, as support for dictionary based record
encoding as been erroded by field additions and the pain of updating a static
dictionary in a distributed system.

The subscription management is built into the RV system.  Each unique endpoint
identifies itself using the IP address of the interface and a timestamp of the
daemon startup.  The subscriptions are reasserted every 90 seconds by
publishing a *HOST.STATUS* message.  When the transport is disrupted, the
subscriptions can be obtained from the host by querying it.  Each host is
reachable on a well known subject *_INBOX.hostip.DAEMON*.  The main drawback of
this management method is the 90 seconds interval, which can lead to long
periods of outages bounded by 90 second intervals before a subject stream
reestablishes the cached state.  Any switch or network element in between the
subscriber and the publisher which drops the multicast *UDP* packets can cause
a a long disruption in the subscriptions that were dropped.

The advantages of *SASS2* are that it is a low overhead system without a lot of
subscription management traffic during normal operation.  The successor to
*SASS2*, called *SASS3*, adds reassert type messages and each subscriber
publishes these on a randomized interval.  The *_INBOX.hostip.DAEMON* is no
longer supported since the Tibco archetecture introduced subject based routers
(rvrd) where the network *IP* addresses may be using *NAT* translation between
segments or may not be directly reachable through *IP* routers.  When these are
present, the *_INBOX* addresses used for point to point communication are
modified as they progress through the *rvrd* routers.  For example, a
*_INBOX.hostip.timestamp.N* subscriber endpoint is modified to be
*_INBOX.routerip.timestamp._INBOX.hostip.timestamp.N*.  This type of
infrastructure using *rvrd* is uncommon.  Reuters used its own method for
connecting across network boundaries through the use of it's market data hub
products which contained the *SASS2* and *SASS3* protocols because the finance
portion of Tibco products were transfered to Reuters.

Subscription Listen/Unsubscribe
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The *SASS2* portion of the subscription mechanics are defined by the basic
operation of *RV*, they were organically defined in the original *SASS* market
data platform and evolved into *RV*.

*SASS2* Subscription Request
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A subscription generates this message:

   _RV.INFO.SYSTEM.LISTEN.START.subject : {
     return : _INBOX.hostip.timestamp.N,
     data : {
       ADV_CLASS : INFO,
       ADV_SOURCE : SYSTEM,
       ADV_NAME : LISTEN.START.subject
       id : hostip.timestamp,
       sub : subject,
       refcnt : counter
     }
   }

The *sub* and *id* fields identify the subject and the subscriber making the
subscription, the optional return field requests that an inital response is
desired.  In recent versions of the Tibrv API, it is not possible to specify
the return field in a subscription request.  The *refcnt* is incremented and
decremented by the same subscriber *id* starting the same subscription.  This
is uncommon since most Tib APIs will not allow this.

*SASS2* Snapshot Request
^^^^^^^^^^^^^^^^^^^^^^^^

A well known endpoint that receives:

  _SNAP.subject : {
    return : _INBOX.hostip.timestamp.N,
    flags : mask
  }

The snapshot image is returned to the *_INBOX* address.  The optional flags can
additionally specify that a subscription should start (flags = 6, the same as
the *T* flag in *SASS3* request described below).  This allows Tibrv API
subscriber to request an initial value with a return *_INBOX*, which is no
longer possible with the *LISTEN.START* message when using the Tibrv API.

*SASS2* Unsubscribe Request
^^^^^^^^^^^^^^^^^^^^^^^^^^^

An unsubscribe generates this message:

   _RV.INFO.SYSTEM.LISTEN.STOP.subject : {
     data : {
       ADV_CLASS : INFO,
       ADV_SOURCE : SYSTEM,
       ADV_NAME : LISTEN.STOP.subject,
       id : hostip.timestamp,
       sub : subject,
       refcnt : counter
     }
   }

*SASS3* Subscription Request
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A well known endpoint is defined for each service on a subject domain, for
example, *_SASS.NASDAQ.SUB*.  This message is published by the subscriber for
subscription operations:

  _SASS.svc.SUB : {
    return : _INBOX.hostip.timestamp.N,
    data : {
      M : sub_magic,
      T : flags,
      A : {
        U : user,
        H : host,
        A : program,
        P : process-id
      }
      S : subject
    }
  }

The *sub_magic* is always the value 23176.  The *S* and *A* fields identify the
subject and the subscriber making the subscription, and the *T* flags is a bit
mask identifing what operation is requested:

[grid=cols,cols=2]
|====
|SNAPSHOT_FLAG        | 0x01
|SUBSCRIBE_FLAG       | 0x02
|INITIAL_VALUES_FLAG  | 0x04
|UNSUBSCRIBE_FLAG     | 0x08
|REFRESH_FLAG         | 0x10
|RESUBSCRIBE_FLAG     | 0x80
|====

The *A* field is commonly combined into a string as *user@host/program#pid*.
This endpoint merges the basic subscription operations: Subscription,
Subscription Image, Snapshot, Refresh Image, Subscription Reassert,
Unsubscribe.  The advantages of a *SASS3* request are that the subsccriber is
identified by a readable string rather than a hostip and timestamp and that
many of the operators for asserting subscriptions are combined into one
publish.  The disadvantage is that the service endpoint needs to be defined and
the host field does not need to identify the IP address of the subscribers
making the request.

Reassert Subscription
~~~~~~~~~~~~~~~~~~~~~

*SASS2* Reassert Subscription
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A *SASS2* subscription managment database is necessary to ensure that the
*HOST.STATUS* is updated every 90 seconds.  Every subscription contains an *id*
which identifies the daemon endpoint that can be queried to obtain the current
subscription state.  This is the *HOST.STATUS* message (missing some fields for
brevity):

  _RV.INFO.SYSTEM.HOST.STATUS.hostip : {
    ADV_CLASS : INFO,
    ADV_SOURCE : SYSTEM,
    ADV_NAME : HOST.STATUS.hostip,
    hostaddr : ipaddress,
    time : milliseconds,
    service : service-number,
    network : network-spec
    ...
  }

The *hostip* part of the subject reasserts all subscriptions with the *id*
*hostip.timestamp* or *hostip.DAEMON.timestamp*, which were specified by the
*LISTEN.START* message.  If there is message loss on the transport or the
*HOST.STATUS* message does not get received by the subscription manager at the
time expected, it uses point to point requests to retrieve the current
subscription state.

There are two queries to obtain the state of subscriptions, the session
query and the subscription query.  The session query lists the subscriber
sessions attached to a daemon.  The subscription query lists the subject
attached to a session(s).

The format of the session state queries are:

  _INBOX.hostip.DAEMON : {
    return : _INBOX.hostip.timestamp.N,
    data : {
      op : get,
      what : sessions
    }
  }

The format of the subscripion state queries are:

  _INBOX.hostip.DAEMON : {
    return : _INBOX.hostip.timestamp.N,
    data : {
      op : get,
      what : subscriptions,
      session : hostip.timestamp
    }
  }

The return of the session state query is a list of sessions, which match
the *id* of the *LISTEN.START* notifications:

  _INBOX.hostip.timestamp.N : {
    null : hostip.DAEMON.timestamp,
    null : hostip.timestamp,
    null : hostip.timestamp
  }

Each of these sessions can be used to retrieve the subscriptions using the
subscription state query above, this returns a list of subjects:

  _INBOX.hostip.timestamp.N : {
    user : nobody
    null : subject
    null : subject
    end  : 1
  }

*SASS3* Reassert Subscription
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The *_SASS.svc.SUB* method of starting subscriptions can contain a list of
subjects.  Although the list can be used to mass start or stop subscriptions,
the primary use is to reassert them.  After the list is processed by the
manager, an *ACK* is published to the return subject.  If this message is used
for reassert:

  _SASS.svc.SUB : {
    return : _INBOX.hostip.timestamp.N,
    data : {
      M : sub_magic,
      T : RESUBSCRIBE_FLAG,
      A : {
        U : user,
        H : host,
        A : program,
        P : process-id
      }
      S : subject1,
      S : subject2,
      S : subject3
    }
  }

The *T* field is the same as the *SASS3* subscription request above, where 0x80
is the mask bit for *RESUBSCRIBE_FLAG*.

After processing the reassert message, the publisher sends an *ACK* to the
return subject:

  _INBOX.hostip.timestamp.N : {
    data : {
      M : pub_magic,
      I : 0x20,
      T : VERIFY,
      S : OK,
      D : {
        S : subject1,
        S : subject2,
        S : subject3
      }
    }
  }

This is an active method of reasserting compared to the *SASS2* method.  The
advantage of *SASS3* is that the status of the subscriptions can be updated by
the manager as a list.  The *T* and the *S* fields are derived from the
*MSG_TYPE* and *REC_STATUS* fields of the updates.  The *SASS2* passive method
allows for simpler subscribers and both protocols will update the status of the
subjects via update publishes.

Subscription Initial/Snapshot
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In all cases the initial value is sent point to point using the return argument
provided by the subscrtion start.  The first subject that is subscribed by a
*RV* subscriber when the connection is established to the daemon is the
*_INBOX.hostip.timestamp.>* subject, which is globably unique in the *rvd*
subject domain (but not in rvrd's).  All of the return values normally contain
this prefix, since the subscription is already started.  When an inbox is
provided by the Tib APIs, it is incrmenting an integer and appending it to the
base after the timestamp, for example *_INBOX.hostip.timestamp.2*.  The
*_INBOX.hostip* prefix also causes the subject to be routed over point to point
links instead of multicast.  Since the *IP* routing and the reliability of the
protocols is defined for each stream type, the point to point and mcast
messages arrive independent of one another, no ordering between them is
guarenteed.

*SASS2* Initial/Snapshot
^^^^^^^^^^^^^^^^^^^^^^^^

The message arriving using the return subject does not contain the original
subscription subject, so this mapping of *_INBOX* string to subject must be
maintained by the subscriber.  The *SASS* header *MSG_TYPE* is usually modified
by the publisher to indicate what kind of data is present, either *INITIAL* of
*SNAPSHOT* is a normal response, and others have special status, *TRANSIENT* is
used for not found or not available, *DROP* is used when a subject is expired
and no longer available, *VERIFY* is used to prepare the subscriber for
updates.  In addition, the *REC_STATUS* field may contain *STALE* for out of
date records, *NOT_FOUND* when no record is present, *TEMP_UNAVAIL*,
*BAD_NAME*, *BAD_LINE*, *FEED_DOWN* for publisher errors that are not normal.
Other values can be used by the publishers, depending on the data source and
the publisher implementation.

A normal return value is:

  _INBOX.hostip.timestamp.N : {
    MSG_TYPE : INTIAL,
    REC_TYPE : NMTS,
    SEQ_NO : 1001,
    REC_STATUS : OK,
    <msg data>
  }

A Not Found return value is:

  _INBOX.hostip.timestamp.N : {
    MSG_TYPE : TRANSIENT
    REC_STATUS : NOT_FOUND
  }

A Stale return value is:

  _INBOX.hostip.timestamp.N : {
    MSG_TYPE : INTIAL,
    REC_TYPE : NMTS,
    SEQ_NO : 1001,
    REC_STATUS : STALE,
    <other data fields>
  }

The only difference for a snapshot is the *MSG_TYPE*, which will contain
*SNAPSHOT* instead of *INITIAL* in the case that a data value is returned.
The *REC_TYPE* does not need to be defined anymore, so it may be absent or
zero.

*SASS3* Initial/Snapshot
^^^^^^^^^^^^^^^^^^^^^^^^

The *SASS3* protocol uses an header envelope which has the same semantics as
*SASS2*, but the coding of the record can be in *Marketfeed* format in addition
to the *SASS2* formats, which are *TibMsg* or *SASS Qform*.  This format may
not have the same status fields of *MSG_TYPE* and *REC_STATUS*.  The *SASS3*
envelope still uses the same status value as *SASS2*.  This is a normal return
value:

  _INBOX.hostip.timestamp.N : {
    M : pub_magic,
    T : INITIAL,
    S : OK
    D : {
      <msg data>
    }
  }

The *pub_magic* is always the value 23177.  The *T* field is equivalent to the
*MSG_TYPE* field and the *S* field is equivalent to the *REC_STATUS* field.

A Not Found return value is:

  _INBOX.hostip.timestamp.N : {
    M : pub_magic,
    T : TRANSIENT,
    S : NOT_FOUND
  }

A Stale return value is:

  _INBOX.hostip.timestamp.N : {
    M : pub_magic,
    T : INITIAL,
    S : STALE,
    D : {
      <msg data>
    }
  }

Update Publish
~~~~~~~~~~~~~~

Updates are multicast to the subscription.  These are delta changes to the
initial value.  It may be an *INITIAL* indicating all fields are present or
some other type with a subset of the fields.  An *INITIAL* is often used when
the publisher adds or removes a field from the initial value, or wants to
ensure that the subscribers are up to date by publishing the inital on a timer.

A *SASS2* update contains the same header as the initial with the *MSG_TYPE*
usually set to *UPDATE* or a status that is has additional semantics to that,
such as *CORRECT* or *CLOSING*.  

SASS2 Update
^^^^^^^^^^^^

  NASDAQ.REC.INTC.O : {
    MSG_TYPE : UPDATE,
    REC_TYPE : NMTS,
    SEQ_NO : 1002,
    REC_STATUS : OK,
    <msg data>
  }

SASS3 Update
^^^^^^^^^^^^

  NASDAQ.REC.INTC.O : {
    M : pub_magic,
    T : UPDATE,
    S : OK,
    D : {
      <msg data>
    }
  }

The *SASS3* case may omit the *T* and *S* fields as they default to these
values when not present.

Drop Notification
~~~~~~~~~~~~~~~~~

A *MSG_TYPE* which contains a *DROP* code indicates that the publisher is not
going to update a subject.  The subscription itself stays open until the
subscriber closes it.  When the *REC_STATUS* contains the status for
*NOSUBSCRIBERS*, the publisher has no active subscribers in the subscription
management database and reasserting the subscription will restart it.  This
case is rarely seen by subscribers unless they are using a wildcard.  All the
other *REC_STATUS* codes can only be reestablished by reasserting when the
subject state is reinitialized.  The subscriber can try, but the result is
usually a *NOT_FOUND* status.

NATS
----

NATS does not natively have subscription management, so much of the caching
semantics has to be layered on top of the base pubsub system.

Todo.. describe NATS + subscription management.

Redis
-----

Redis also does not nately have subscripton management, but it does have a
complex array of caching semantics that may be used.

Todo.. describe Redis + subscription management.

Http/Websocket
--------------

This is basically the same as the Redis case, since the caching semantics
works as the Redis RESP protocol is layered over the Websocket protocol.

OpenPGM
-------

This is a transport, not a pubsub sytem.  The history of PGM flows through
early caching systems by Tibco, to RFC, to open source.

Todo.. describe OpenPGM + pubsub + subscription management.
